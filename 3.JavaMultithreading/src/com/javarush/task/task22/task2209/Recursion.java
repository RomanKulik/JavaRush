package com.javarush.task.task22.task2209;


/**
 * Выводит все возможные варианты расположения элементов массива без повтора
 * https://www.cyberforum.ru/java-j2se/thread1513535.html
 */
public class Recursion {
    private static int count = 0;
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        permute(arr, arr.length);
    }

    private static void permute(int[] arr, int size) {
        int k = 0, r = 0;
        if (size < 2) {
           // System.out.println(Arrays.toString(arr));
            System.out.println("size < 2, k = " + k);
        } else {
            for (k = 0; k < size; k++) {
                System.out.println(r++);
                swap(arr, k, size - 1);
                permute(arr, size - 1);
                swap(arr, size - 1, k);
                System.out.println("for inside: " + k);
            }
            System.out.println("for outside: " + k);
        }
    }

    private static void swap(int[] arr, int k, int i) {
        int tmp = arr[k];
        arr[k] = arr[i];
        arr[i] = tmp;
        System.out.println("count = "+ ++count);
    }
}

/*
https://thecode.media/all-combo/
// Массив для результатов перестановок

        // рекурсивная функция
        // на вход получает текущий массив и массив с памятью предыдущих вычислений

        // переменная для хранения фрагмента массива

        // делаем переменную для хранения промежуточных результатов
        // в программировании это называется «мемоизация»

        // какой размер входного массива — такой длины и делаем цикл,
        // перебрать все элементы

        // получаем новый массив cur, удаляя из входного массива один элемент,
        // начиная с текущей позиции
        // при этом из входного массива этот элемент тоже удалится

        // если от входного массива ничего не осталось
        // то приклеиваем текущее значение нарезки к варианту, который лежит в памяти,
        // и добавляем получившийся результат в итоговый массив


        // вызываем новый виток рекурсии
        // в качестве аргументов передаём копию входящего массива
        // и добавляем к кешу памяти то, что получилось
        // после удаления одного символа из входящего массива


        // возвращаем в исходный массив первый элемент из нового массива,
        // но уже на другую позицию


        // возвращаем обратно массив с результатами перестановок
 */