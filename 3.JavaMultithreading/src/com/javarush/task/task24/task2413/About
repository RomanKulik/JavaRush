Арканоид(1)
Давай сегодня напишем игру Арканоид.

В оригинале это выглядит примерно так (https://www.youtube.com/watch?v=Th-Z6QQ5AOQ)
Для начала мы напишем упрощенную версию этой игры.
У нас будут кубики, шарик и летающая "подставка", которая не дает шарику упасть.

Поэтому нам понадобятся классы:
а) Arkanoid - класс в котором происходят основные действия. Также в нем будет наша точка входа в программу, метод main.
б) Ball - шарик.
в) Brick - "кирпичи", которые мы сбиваем шариком.
г) Stand - летающая подставка.

Создай их, и не забудь о методе public static void main (String[] args) в классе Arkanoid.


Requirements:
1. Класс Arkanoid должен быть создан в отдельном файле.
2. Класс Ball должен быть создан в отдельном файле.
3. Класс Brick должен быть создан в отдельном файле.
4. Класс Stand должен быть создан в отдельном файле.
5. В классе Arkanoid должен быть создан метод public static void main(String[] args).

Арканоид(2)
Главному классу (Arkanoid) нужно будет хранить информацию о размерах поля, где будут происходить все действия.

Поэтому:
а) добавь в класс Arkanoid два приватных поля width(ширина) и height(высота) типа int
б) создай для них публичные геттеры и сеттеры


Requirements:
1. В классе Arkanoid должно быть создано приватное поле width типа int.
2. В классе Arkanoid должно быть создано приватное поле height типа int.
3. В классе Arkanoid должен быть создан корректный геттер для поля height.
4. В классе Arkanoid должен быть создан корректный геттер для поля width.
5. В классе Arkanoid должен быть создан корректный сеттер для поля height.
6. В классе Arkanoid должен быть создан корректный сеттер для поля width.

Арканоид(3)
Пожалуй, пора добавить конструктор в класс Arkanoid.
Конструктор должен принимать два параметра типа int (width и height) и корректно устанавливать значения соответствующих полей класса.


Requirements:
1. В классе Arkanoid должен быть создан публичный конструктор с двумя параметрами типа int.
2. Конструктор класса Arkanoid должен корректно устанавливать значения соответствующих полей класса.


Арканоид(4)
Также классу Arkanoid нужно будет хранить ссылку на шарик (Ball), "подставку" (Stand) и список "кирпичей" (List<Brick>).

Нужно в классе Arkanoid:
а) создать приватное поле ball типа Ball
б) создать приватное поле stand типа Stand
в) создать приватное поле bricks типа List<Brick>
г) добавить для них публичные геттеры и сеттеры


Requirements:
1. В классе Arkanoid должно быть создано приватное поле ball типа Ball.
2. В классе Arkanoid должно быть создано приватное поле stand типа Stand.
3. В классе Arkanoid должно быть создано приватное поле bricks типа List<Brick>.
4. В классе Arkanoid должен быть создан корректный геттер для поля ball.
5. В классе Arkanoid должен быть создан корректный геттер для поля stand.
6. В классе Arkanoid должен быть создан корректный геттер для поля bricks.
7. В классе Arkanoid должен быть создан корректный сеттер для поля ball.
8. В классе Arkanoid должен быть создан корректный сеттер для поля stand.
9. В классе Arkanoid должен быть создан корректный сеттер для поля bricks.


Арканоид(5)
Чего еще не хватает классу Arkanoid?
Во-первых ему нужен метод run(), в котором будет описана основная логика программы.
Еще нужен метод move() - который будет двигать на один шаг все объекты требующие движения.
Создай методы run() и move().

Еще нам понадобится НЕ приватная статическая переменная game типа Arkanoid, которая будет хранить ссылку на созданный экземпляр класса Arkanoid.

Выглядеть это должно примерно так:
static Arkanoid game;


Requirements:
1. В классе Arkanoid должен быть создан метод void run() без параметров.
2. В классе Arkanoid должен быть создан метод void move() без параметров.
3. Метод run должен быть доступен извне класса Arkanoid.
4. Метод move должен быть доступен извне класса Arkanoid.
5. В классе Arkanoid должно быть создано не приватное статическое поле game типа Arkanoid.


Арканоид(6)
У нас будут "кирпичи", "шарик" и "подставка" и у них будет много общего.
Они будут перемещаться по полю и отрисовываться.
Значит у них у всех будут координаты и размер.
А еще методы move() - для перемещения и draw() для отрисовки.

Есть интересное предложение: давай введем один базовый класс для всех объектов.
Пусть это будет класс BaseObject.
А классы Ball, Stand, Brick от него наследуются.

Создай класс BaseObject и добавь его родителем к классам Ball, Stand, Brick.

Еще нам понадобится класс Canvas.
Он будет ответственным за "отрисовку" объектов.
С помощью его они будут отрисовывать себя.
Вернее даже на нем, но детали я сообщу позднее.

Создай и этот класс.


Requirements:
1. Публичный класс BaseObject должен быть создан в отдельном файле.
2. Класс Canvas должен быть создан в отдельном файле.
3. Класс Ball должен быть потомком класса BaseObject.
4. Класс Brick должен быть потомком класса BaseObject.
5. Класс Stand должен быть потомком класса BaseObject.


Арканоид(7)
Теперь перейдем к классу BaseObject.
Я хочу сделать несколько предложений.

Во-первых для простоты считать что все объекты у нас будут круглыми.
Нет, отрисовывать их мы будем фигурными, как и раньше.
А вот при расчетах из взаимодействия исходить из того, что они круглые.
Так - гораздо проще.

Во-вторых. Пусть координаты объектов и радиус будут вещественными числами.
Это придаст плавность движениям и точность всем вычислениям.
А при отрисовке мы будем их округлять.

Итак:
а) Добавь в класс BaseObject приватные поля x (double), y (double), radius (double).
б) Добавь геттеры и сеттеры.
в) Добавь конструктор BaseObject(double x, double y, double radius).
г) Пройдись по всем классам-наследникам и поправь у них конструкторы.

Если ты используешь Intellij IDEA - Alt+Insert тебе в помощь.


Requirements:
1. В классе BaseObject должно быть создано приватное поле x типа double.
2. В классе BaseObject должно быть создано приватное поле y типа double.
3. В классе BaseObject должно быть создано приватное поле radius типа double.
4. В классе BaseObject должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
5. В классе Ball должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
6. В классе Brick должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
7. В классе Stand должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
8. В классе BaseObject должен быть создан публичный геттер для поля x.
9. В классе BaseObject должен быть создан публичный геттер для поля y.
10. В классе BaseObject должен быть создан публичный геттер для поля radius.
11. В классе BaseObject должен быть создан публичный сеттер для поля x.
12. В классе BaseObject должен быть создан публичный сеттер для поля y.
13. В классе BaseObject должен быть создан публичный сеттер для поля radius.


Арканоид(8)
Но и это еще не все.
Классу BaseObject нужны еще методы.
Пока это будут пустые методы draw(Canvas canvas) и move().
Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность (пока можешь оставить их пустыми, просто чтобы код компилировался).
Объяви эти методы, но сделай их абстрактными.
Также сделай абстрактным сам класс BaseObject.

А еще нам нужно будет определять попал ли шарик в кирпич или в подставку.
Это будем делать так:
В этом же классе, создадим специальный метод: boolean intersects(BaseObject o)
Он будет определять - "пересеклись" объекты или нет. Если пересеклись - возвращать true, если нет - false.

Т.к. объекты мы условно считаем кругами, то предлагаю такую формулу взаимодействия:
если центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.

Или еще проще:
дистанция_между_объектами <= max (радиус_первого_объекта, радиус_второго_объекта)

Дистанция между объектами A и B на плоскости вычисляется по теореме Пифагора по формуле:
дистанция_между_объектами_A_B = квадратный_корень(
квадрат_числа(координата_x_объекта_B - координата_x_объекта_A) +
квадрат_числа(координата_y_объекта_B - координата_y_объекта_A)
)
Квадратный корень можно получить используя метод Math.sqrt(). Квадрат числа можно получить используя метод Math.pow(), где первый аргумент - это число, второй аргумент - степень, к которой нужно возвести число.
Или еще проще используя метод Math.hypot().


Requirements:
1. Класс BaseObject должен быть абстрактным.
2. В классе BaseObject должен быть объявлен абстрактный метод void draw() c одним параметром типа Canvas.
3. В классе BaseObject должен быть объявлен абстрактный метод void move() без параметров.
4. В классе BaseObject должен быть реализован метод intersects() с одним параметром типа BaseObject, возвращающий true в случае, если текущий объект пересекается с анализируемым.


Арканоид(9)
Теперь займемся классом Canvas.
Он у нас будет содержать матрицу (двумерный массив), куда мы будем "рисовать".
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).

Надо:
а) Добавить в класс два приватных поля width и height.
б) Добавить в класс приватное поле matrix (char[][]).
в) Добавить конструктор с двумя параметрами типа int (width и height), поле matrix должно быть инициализировано пустым массивом размерностью [height+2][width+2].
г) Добавить геттеры и сеттеры для всех приватных полей класса.


Requirements:
1. В классе Canvas должно быть создано приватное поле width типа int.
2. В классе Canvas должно быть создано приватное поле height типа int.
3. В классе Canvas должно быть создано приватное поле matrix типа char[][].
4. В классе Canvas должен быть создан публичный геттер для поля width.
5. В классе Canvas должен быть создан публичный геттер для поля height.
6. В классе Canvas должен быть создан публичный геттер для поля matrix.
7. В классе Canvas должен быть создан публичный сеттер для поля width.
8. В классе Canvas должен быть создан публичный сеттер для поля height.
9. В классе Canvas должен быть создан публичный сеттер для поля matrix.
10. В классе Canvas должен быть создан корректный публичный конструктор с двумя параметрами типа int (width и height).


Арканоид(10)
Что мы будем делать с Canvas?
Мы будем рисовать на нем (в его матрице).
Поэтому нам понадобятся два метода:
void setPoint(double x, double y, char c)
void drawMatrix(double x, double y, int[][] matrix, char c)

Первый метод - setPoint будет "ставить точку в координатах x,y цветом c".

В методе надо:
а) округлить x и y до целых чисел, используя метод Math.round()
б) занести в matrix[y][x] значение с
в) ничего не делать, если x < 0 или y < 0 или y >= matrix.length или x >= matrix[0].length

Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
И не просто копирует, а начиная с координат x, y

В методе надо:
а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки
б) если значение ячейки элемента [i][j] полученной матрицы не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
setPoint(x+j, y+i, c)


Requirements:
1. В классе Canvas должен быть создан метод void setPoint(double x, double y, char c).
2. В классе Canvas должен быть создан метод void drawMatrix(double x, double y, int[][] matrix, char c).
3. Поведение метода setPoint должно соответствовать условию задачи.
4. Поведение метода drawMatrix должно соответствовать условию задачи.

Арканоид(11)
Еще Canvas понадобится два метода, напиши их.
а) метод clear()
Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
Можешь просто заново инициализировать matrix пустым массивом правильной размерности.
б) метод print()
Этот метод рисует матрицу на экран.
Тут уже ты должен сам разобраться: вывести набор символов не так уж и сложно.


Requirements:
1. В классе Canvas должен быть создан метод void clear() без параметров.
2. В классе Canvas должен быть создан метод void print() без параметров.
3. Метод clear должен очищать массив matrix.
4. Метод print должен выводить на экран содержимое массива matrix.


Арканоид(12)
Теперь займемся классом Brick.

Во-первых, в конструкторе точно зададим "радиус" всех кирпичей.
Пусть он выглядит так:
public Brick(double x, double y) {
  super(x, y, 3);
}

Еще убедись, что в классе Brick есть два переопределенных метода: move() и draw(Canvas canvas).
Метод move() не делает ничего (не содержит кода), т.к. кирпич никуда не двигается.

Кодом метода draw(Canvas canvas) я займусь сам.


Requirements:
1. Конструктор класса Brick должен принимать два параметра типа double и вызывать конструктор класса родителя с фиксированным третьим параметром (радиусом) равным 3.
2. В классе Brick должен существовать метод move без параметров.
3. В классе Brick должен существовать метод draw с одним параметром типа Сanvas.

Арканоид(13)
Класс Ball уже посложнее - шарик же двигается.

Нам понадобятся приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения в градусах: от 0 до 360) типа double;
в) dx (расстояние по x, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
г) dy (расстояние по y, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
д) isFrozen ("истина" если шарик "заморожен" - не двигается) типа boolean.

Не забудь добавить геттеры для всех полей этого класса, кроме isFrozen (его мы будем использовать только внутри класса Ball).

А еще сделай-ка конструктор:
а) параметры - x, y, speed, direction;
б) радиус (для вызова родительского класса) всегда равен 1;
в) не забудь установить isFrozen в true - в начале игры шарик никуда не летит.


Requirements:
1. Приватное поле speed типа double должно быть создано в классе Ball.
2. Приватное поле direction типа double должно быть создано в классе Ball.
3. Приватное поле dx типа double должно быть создано в классе Ball.
4. Приватное поле dy типа double должно быть создано в классе Ball.
5. Приватное поле isFrozen типа boolean должно быть создано в классе Ball.
6. В классе Ball должен быть создан публичный конструктор (поведение и параметры описаны в условии).
7. В классе Ball должен существовать корректный публичный геттер для поля speed.
8. В классе Ball должен существовать корректный публичный геттер для поля direction.
9. В классе Ball должен существовать корректный публичный геттер для поля dx.
10. В классе Ball должен существовать корректный публичный геттер для поля dy.


Арканоид(14)
Чего-то не хватает в классе Ball:

Во-первых надо реализовать метод move(), унаследованный от BaseObject:
а) x должен увеличиваться на dx каждый ход
б) y должен увеличиваться на dy каждый ход
если шарик "заморожен", то x и y меняться не должны

Во-вторых надо реализовать метод draw(Canvas canvas):
на объекте canvas необходимо вызвать метод setPoint с параметрами (x, y, 'O')

В-третьих надо создать и реализовать метод void start():
именно его вызов "размораживает" шарик.
Что для этого надо сделать - это ты уже сам реши.

P.S. Чуть не забыл! Поля x, y и radius объявлены в классе BaseObject с модификатором доступа private, что не очень-то удобно.
Измени его на protected, чтобы все потомки класса BaseObject имели контроль над своими координатами и размерами, без необходимости пользоваться " чужими" геттерами и сеттерами.


Requirements:
1. Метод move() в классе Ball должен увеличивать значение x на dx, если значение поля isFrozen равно false.
2. Метод move() в классе Ball должен увеличивать значение y на dy, если значение поля isFrozen равно false.
3. Метод move() в классе Ball не должен менять значения полей x и y, если значение поля isFrozen равно true.
4. В классе Ball должен быть реализован метод draw(Canvas canvas) в соответствии с условием задачи.
5. В классе Ball должен быть реализован метод start() устанавливающий значение поля isFrozen в false.
6. Модификатор доступа поля x в классе BaseObject должен быть изменен на protected.
7. Модификатор доступа поля y в классе BaseObject должен быть изменен на protected.
8. Модификатор доступа поля radius в классе BaseObject должен быть изменен на protected.


Арканоид(15)
Не поверишь, но и это еще не все. Продолжим реализацию класса Ball.

Во-первых нужен метод setDirection, который не только устанавливает значение переменной direction, но и вычисляет новые значения переменных dx и dy.

Код должен выглядеть примерно так:
this.direction = direction;
double angle = Math.toRadians(direction);
dx = Math.cos(angle) * speed;
dy = -Math.sin(angle) * speed.

Во-вторых шарик может удариться о стенку.
При этом он должен от нее отскочить.

Для этого нам понадобится еще один метод:
void checkRebound(int minx, int maxx, int miny, int maxy)

Создай его, а кодом я займусь сам.


Requirements:
1. В классе Ball должен быть создан метод void setDirection() c одним параметром типа double (реализацию смотри в условии).
2. В классе Ball должен быть создан метод void checkRebound c четырьмя параметрами типа int.


Арканоид(16)
И наконец "подставка"!
Ей понадобятся такие приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения по оси x: 1 - вправо, -1 - влево, 0 - начальное значение, стоим на месте) типа double.

Также создай для них геттеры.

А еще с тебя конструктор, примерно вот такой:
public Stand(double x, double y) {
super(x, y, 3);
speed = 1;
direction = 0;
}


Requirements:
1. В классе Stand должно быть создано приватное поле speed типа double.
2. В классе Stand должно быть создано приватное поле direction типа double.
3. В классе Stand должен быть реализован публичный геттер для поля speed.
4. В классе Stand должен быть реализован публичный геттер для поля direction.
5. В классе Stand должен быть реализован конструктор с двумя параметрами типа double в соответствии с условием задачи.

